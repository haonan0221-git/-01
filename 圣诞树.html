<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Christmas Tree (Final Fix)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* HUD Interface */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        .hud-top { padding: 20px; color: #FFD700; pointer-events: auto; background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent); }
        h1 { margin: 0; font-size: 20px; letter-spacing: 1px; }
        p { font-size: 12px; color: #ccc; margin: 5px 0 0 0; }
        
        /* Debug Console on Screen */
        #debug-console {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 80%; text-align: center; color: #fff; z-index: 100;
            font-size: 16px; text-shadow: 0 2px 4px #000; pointer-events: none;
        }
        .error-msg { color: #ff4444; background: rgba(0,0,0,0.8); padding: 10px; border-radius: 4px; }

        /* Camera Preview */
        #video-feed {
            position: absolute; bottom: 10px; right: 10px; width: 120px; height: 90px;
            transform: scaleX(-1); border: 2px solid #333; border-radius: 8px;
            opacity: 0.6; z-index: 20; object-fit: cover;
        }

        /* Status Text */
        #gesture-status {
            position: absolute; bottom: 120px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.2); font-size: 24px; font-weight: bold;
            pointer-events: none; transition: 0.3s;
        }
        .active-gesture { color: #FFD700 !important; text-shadow: 0 0 15px #FFD700; transform: scale(1.2); }

        .upload-btn {
            display: inline-block; margin-top: 10px; padding: 6px 12px;
            border: 1px solid #FFD700; color: #FFD700; border-radius: 4px;
            font-size: 12px; cursor: pointer; pointer-events: auto;
        }
        input[type="file"] { display: none; }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="debug-console">Initializing 3D Engine...</div>

    <div id="ui-layer">
        <div class="hud-top">
            <h1>üéÑ MAGIC GESTURE TREE</h1>
            <p>üñê Open: Explode | ‚úä Fist: Gather | üëå Pinch: Grab</p>
            <label class="upload-btn">
                UPLOAD PHOTOS
                <input type="file" id="file-input" multiple accept="image/*">
            </label>
        </div>
        <div id="gesture-status">WAITING FOR CAMERA...</div>
    </div>

    <video id="video-feed" playsinline></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // Log helper
        function log(msg, isError = false) {
            const el = document.getElementById('debug-console');
            el.innerHTML = msg;
            if(isError) el.className = 'error-msg';
            console.log(msg);
        }

        // --- Configuration ---
        const CONFIG = {
            colors: { green: 0x2F4F4F, gold: 0xFFD700, red: 0x8B0000 },
            particleCount: 1200,
            treeHeight: 600, treeRadius: 250, scatterRadius: 800
        };

        let scene, camera, renderer, composer;
        let particles = [], photos = [];
        let geometryGroup = new THREE.Group();
        let photoGroup = new THREE.Group();
        let currentMode = 'TREE';
        let activePhoto = null;
        let targetRotX = 0, targetRotY = 0;

        // --- 1. Three.js Setup ---
        function initThree() {
            try {
                const container = document.getElementById('canvas-container');
                scene = new THREE.Scene();
                scene.fog = new THREE.FogExp2(0x050505, 0.0008);

                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 3000);
                camera.position.set(0, 200, 1000);

                renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.toneMapping = THREE.ReinhardToneMapping;
                container.appendChild(renderer.domElement);

                // Lights
                scene.add(new THREE.AmbientLight(0x404040, 2));
                const pl = new THREE.PointLight(CONFIG.colors.gold, 2, 1500);
                pl.position.set(0, 500, 200);
                scene.add(pl);
                
                // Bloom
                const renderScene = new RenderPass(scene, camera);
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.threshold = 0; bloom.strength = 1.2; bloom.radius = 0.5;
                composer = new EffectComposer(renderer);
                composer.addPass(renderScene);
                composer.addPass(bloom);

                // Content
                createDecorations();
                createPlaceholders();
                scene.add(geometryGroup);
                scene.add(photoGroup);

                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    composer.setSize(window.innerWidth, window.innerHeight);
                });

                document.getElementById('file-input').addEventListener('change', handleUpload);
                
                log("3D Ready. Loading AI...");
                initMediaPipe(); // Start AI after 3D
                animate();
            } catch (e) {
                log("WebGL Error: " + e.message, true);
            }
        }

        // --- 2. Content Creation ---
        function createDecorations() {
            const sphereGeo = new THREE.SphereGeometry(1, 8, 8); // Low poly
            const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.9 });
            const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.2, metalness: 0.8, emissive: 0xaa8800, emissiveIntensity: 0.2 });

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh = new THREE.Mesh(sphereGeo, Math.random() < 0.7 ? matGreen : matGold);
                mesh.scale.setScalar(5 + Math.random() * 8);

                const theta = Math.random() * Math.PI * 2;
                const y = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight / 2;
                const r = CONFIG.treeRadius * (1 - (y + CONFIG.treeHeight/2)/CONFIG.treeHeight) * Math.random();
                
                mesh.userData = {
                    treePos: { x: r * Math.cos(theta), y: y, z: r * Math.sin(theta) },
                    scatterPos: { x: (Math.random()-0.5)*1600, y: (Math.random()-0.5)*1600, z: (Math.random()-0.5)*1600 }
                };
                mesh.position.copy(mesh.userData.treePos);
                geometryGroup.add(mesh);
                particles.push(mesh);
            }
        }

        function createPlaceholders() {
            const ctx = document.createElement('canvas').getContext('2d');
            ctx.canvas.width=300; ctx.canvas.height=400; ctx.fillStyle='#222'; ctx.fillRect(0,0,300,400);
            ctx.fillStyle='#FFD700'; ctx.font='40px Arial'; ctx.fillText('PHOTO', 80, 200);
            const tex = new THREE.CanvasTexture(ctx.canvas);
            for(let i=0; i<8; i++) createPhotoMesh(tex);
        }

        function createPhotoMesh(tex) {
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(30, 40), new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }));
            const y = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight/2;
            const r = (CONFIG.treeRadius * (1 - (y + CONFIG.treeHeight/2)/CONFIG.treeHeight)) + 20;
            const theta = Math.random() * Math.PI * 2;
            
            mesh.userData = {
                treePos: { x: r * Math.cos(theta), y: y, z: r * Math.sin(theta) },
                scatterPos: { x: (Math.random()-0.5)*800, y: (Math.random()-0.5)*800, z: (Math.random()-0.5)*800 }
            };
            mesh.position.copy(mesh.userData.treePos);
            mesh.lookAt(0, y, 0);
            photoGroup.add(mesh);
            photos.push(mesh);
        }

        function handleUpload(e) {
            const files = e.target.files;
            if(!files.length) return;
            for(let i=0; i<files.length; i++) {
                const r = new FileReader();
                r.onload = (ev) => { 
                    const img = new Image(); 
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true; tex.colorSpace = THREE.SRGBColorSpace;
                        createPhotoMesh(tex); 
                    };
                    img.src = ev.target.result; 
                };
                r.readAsDataURL(files[i]);
            }
        }

        // --- 3. Animation Logic ---
        function transformTo(mode) {
            if(currentMode === mode) return;
            currentMode = mode;
            if(activePhoto) {
                new TWEEN.Tween(activePhoto.position).to(activePhoto.userData[mode === 'TREE' ? 'treePos' : 'scatterPos'], 1000).start();
                new TWEEN.Tween(activePhoto.scale).to({x:1,y:1,z:1}, 1000).start();
                activePhoto = null;
            }

            const targetKey = mode === 'TREE' ? 'treePos' : 'scatterPos';
            const ease = mode === 'TREE' ? TWEEN.Easing.Elastic.Out : TWEEN.Easing.Exponential.Out;
            
            particles.forEach(p => new TWEEN.Tween(p.position).to(p.userData[targetKey], 2000).easing(ease).start());
            photos.forEach(p => new TWEEN.Tween(p.position).to(p.userData[targetKey], 2000).easing(ease)
                .onUpdate(() => mode === 'SCATTER' ? p.lookAt(camera.position) : p.lookAt(0, p.position.y, 0)).start());
            
            document.getElementById('gesture-status').innerText = mode === 'TREE' ? "TREE FORM" : "SCATTERED";
        }

        function grabPhoto() {
            if(currentMode === 'ZOOM' || !photos.length) return;
            // Simple grab: pick first photo for demo reliability
            activePhoto = photos[Math.floor(Math.random() * photos.length)];
            currentMode = 'ZOOM';
            
            const target = new THREE.Vector3().copy(camera.position).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(100));
            new TWEEN.Tween(activePhoto.position).to(target, 1000).easing(TWEEN.Easing.Cubic.Out).onUpdate(()=>activePhoto.lookAt(camera.position)).start();
            new TWEEN.Tween(activePhoto.scale).to({x:3,y:3,z:3}, 1000).start();
            document.getElementById('gesture-status').innerText = "PHOTO VIEW";
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();

            if (currentMode === 'SCATTER') {
                camera.position.x += (Math.sin(targetRotY) * 800 - camera.position.x) * 0.05;
                camera.position.y += (Math.sin(targetRotX) * 400 - camera.position.y) * 0.05;
                camera.lookAt(0, 0, 0);
                geometryGroup.rotation.y = Date.now() * 0.0001;
            } else if (currentMode === 'TREE') {
                const t = Date.now() * 0.0005;
                camera.position.x = Math.cos(t) * 1000;
                camera.position.z = Math.sin(t) * 1000;
                camera.position.y = 200;
                camera.lookAt(0, 100, 0);
                geometryGroup.rotation.y = 0;
            }
            composer.render();
        }

        // --- 4. MediaPipe AI (The Hard Part) ---
        async function initMediaPipe() {
            if (!window.Hands) {
                log("MediaPipe JS failed to load. Check Internet.", true);
                return;
            }

            const videoElement = document.getElementById('video-feed');
            
            const hands = new window.Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onResults);

            try {
                // Manually request camera first to debug errors
                const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 320, height: 240, facingMode: "user" } });
                videoElement.srcObject = stream;
                await videoElement.play();
                
                log("Camera OK. Starting AI...");
                
                // Start MediaPipe loop
                const cam = new window.Camera(videoElement, {
                    onFrame: async () => {
                        await hands.send({image: videoElement});
                    },
                    width: 320,
                    height: 240
                });
                await cam.start();
                log(""); // Clear log on success
            } catch (err) {
                log(`Camera Failed: ${err.name}. Allow permission!`, true);
                console.error(err);
            }
        }

        function onResults(results) {
            const statusEl = document.getElementById('gesture-status');
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // 1. Map hand position to rotation (Center is 0.5)
                const handX = (lm[9].x - 0.5) * 2;
                const handY = (lm[9].y - 0.5) * 2;
                if(currentMode === 'SCATTER') {
                    targetRotY = -handX * 2.5; 
                    targetRotX = handY * 2.0;
                }

                // 2. Detect Gestures
                // Dist function
                const d = (i, j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);
                
                // Check if fingers are extended (Tip vs PIP joint)
                const isFingerUp = [8, 12, 16, 20].map(i => lm[i].y < lm[i-2].y).filter(v => v).length;
                const pinch = d(4, 8) < 0.05;

                let gesture = '';
                if (isFingerUp >= 4) gesture = 'OPEN'; // Spread
                else if (isFingerUp === 0 && !pinch) gesture = 'FIST'; // Tree
                else if (pinch) gesture = 'PINCH'; // Grab

                if (gesture === 'FIST') {
                    statusEl.classList.add('active-gesture');
                    transformTo('TREE');
                } else if (gesture === 'OPEN') {
                    statusEl.classList.add('active-gesture');
                    transformTo('SCATTER');
                } else if (gesture === 'PINCH') {
                    statusEl.classList.add('active-gesture');
                    grabPhoto();
                } else {
                    statusEl.classList.remove('active-gesture');
                }
            }
        }

        // Start
        initThree();
    </script>
</body>
</html>
