<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Magic</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; -webkit-tap-highlight-color: transparent; }
        
        /* å¯åŠ¨è¦†ç›–å±‚ */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #start-btn {
            padding: 15px 40px; border: 2px solid #FFD700; background: transparent;
            color: #FFD700; font-size: 18px; border-radius: 30px; cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); text-transform: uppercase;
        }
        
        /* UI - ç§»é™¤äº†ä¸Šä¼ æŒ‰é’® */
        #ui-layer { pointer-events: none; position: absolute; width: 100%; height: 100%; z-index: 10; top:0; left:0;}
        .hud-top { padding: 15px; pointer-events: auto; text-align: center;}
        h1 { color: #FFD700; margin: 0; font-size: 18px; text-shadow: 0 0 10px #FFD700; }
        p { color: #aaa; font-size: 12px; margin: 5px 0; }
        
        #gesture-status {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.3); font-size: 20px; font-weight: bold;
            text-shadow: 0 2px 4px #000; transition: 0.2s;
        }
        .active-gesture { color: #FFD700 !important; text-shadow: 0 0 20px #FFD700; transform: scale(1.1); }

        #video-feed {
            position: absolute; top: 10px; right: 10px; width: 80px; height: 100px;
            transform: scaleX(-1); border: 1px solid #444; opacity: 0.5; object-fit: cover; z-index: 20; border-radius: 5px;
        }

        #error-log {
            position: fixed; bottom: 10px; left: 10px; color: red; font-size: 10px; z-index: 1000;
            background: rgba(0,0,0,0.8); max-width: 80%; pointer-events: none;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="start-overlay">
        <h1 style="margin-bottom: 20px;">ğŸ„ Christmas Magic</h1>
        <button id="start-btn">TAP TO START / ç‚¹å‡»å¼€å§‹</button>
        <div style="margin-top: 10px; font-size: 12px; color: #666;">Allow Camera Access</div>
    </div>

    <div id="error-log"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <h1>NOEL GESTURE</h1>
            <p>ğŸ– Open | âœŠ Fist | ğŸ‘Œ Grab</p>
            </div>
        <div id="gesture-status">WAITING...</div>
    </div>

    <video id="video-feed" playsinline muted></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- æ ¸å¿ƒé…ç½®ï¼šåœ¨è¿™é‡Œä¿®æ”¹ä½ çš„ç…§ç‰‡æ–‡ä»¶å ---
        // ç¡®ä¿ä½ åœ¨ GitHub ä¸Šåˆ›å»ºäº† 'photos' æ–‡ä»¶å¤¹ï¼Œå¹¶æ”¾å…¥äº†è¿™äº›æ–‡ä»¶
        const MY_PHOTOS = [
            'photos/1.jpg',
            'photos/2.jpg',
            'photos/3.jpg',
            'photos/4.jpg',
            'photos/5.jpg' 
            // å¦‚æœä½ æœ‰æ›´å¤šï¼Œç»§ç»­å¾€ä¸‹åŠ  'photos/6.jpg', ç­‰ç­‰
        ];

        function log(msg) {
            console.log(msg);
            if(msg.includes("Error") || msg.includes("Fail")) {
                document.getElementById('error-log').innerText = msg;
            }
        }

        const CONFIG = {
            colors: { green: 0x2F4F4F, gold: 0xFFD700, red: 0xCC0000 },
            particleCount: 1000,
            treeHeight: 600
        };

        let scene, camera, renderer, composer;
        let particles = [], photos = [];
        let geometryGroup = new THREE.Group();
        let photoGroup = new THREE.Group();
        let currentMode = 'TREE';
        let activePhoto = null;
        let targetRotX = 0, targetRotY = 0;

        document.getElementById('start-btn').addEventListener('click', async function() {
            this.innerText = "LOADING...";
            try {
                await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                document.getElementById('start-overlay').style.display = 'none';
                initThree();
                initMediaPipe();
            } catch (e) {
                this.innerText = "CAMERA DENIED / æƒé™è¢«æ‹’ç»";
                log("Error: " + e.message);
                alert("è¯·å…è®¸æ‘„åƒå¤´æƒé™ï¼Œç„¶ååˆ·æ–°é¡µé¢ï¼");
            }
        });

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 1, 2000);
            camera.position.set(0, 100, 900);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.5;
            container.appendChild(renderer.domElement);

            const ambient = new THREE.AmbientLight(0xffffff, 3.0);
            scene.add(ambient);
            const goldLight = new THREE.PointLight(CONFIG.colors.gold, 5.0, 1200);
            goldLight.position.set(200, 300, 300);
            scene.add(goldLight);
            const fillLight = new THREE.DirectionalLight(0xffffff, 2.0);
            fillLight.position.set(0, 0, 500);
            scene.add(fillLight);

            const renderScene = new RenderPass(scene, camera);
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloom.threshold = 0.1; bloom.strength = 1.5; bloom.radius = 0.5;
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloom);

            createContent();
            loadMyPhotos(); // <--- å…³é”®ä¿®æ”¹ï¼šåŠ è½½è‡ªå®šä¹‰ç…§ç‰‡

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
        }

        // æ–°å¢å‡½æ•°ï¼šåŠ è½½é¢„è®¾ç…§ç‰‡
        function loadMyPhotos() {
            const loader = new THREE.TextureLoader();
            
            MY_PHOTOS.forEach(path => {
                loader.load(
                    path, 
                    // æˆåŠŸå›è°ƒ
                    (texture) => {
                        createPhotoMesh(texture);
                    },
                    // è¿›åº¦
                    undefined,
                    // é”™è¯¯å›è°ƒ (å¦‚æœå›¾ç‰‡ä¸å­˜åœ¨)
                    (err) => {
                        console.warn(`æ— æ³•åŠ è½½å›¾ç‰‡: ${path}ã€‚è¯·æ£€æŸ¥GitHubä¸Šçš„æ–‡ä»¶åæ˜¯å¦å®Œå…¨ä¸€è‡´(åŒºåˆ†å¤§å°å†™)ã€‚`);
                    }
                );
            });
        }

        function createContent() {
            const sphereGeo = new THREE.SphereGeometry(1, 8, 8);
            const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.5, metalness: 0.1 });
            const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, roughness: 0.1, metalness: 0.9, emissive: CONFIG.colors.gold, emissiveIntensity: 0.5 });

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh = new THREE.Mesh(sphereGeo, Math.random() < 0.7 ? matGreen : matGold);
                mesh.scale.setScalar(5 + Math.random() * 8);

                const theta = Math.random() * Math.PI * 2;
                const y = Math.random() * CONFIG.treeHeight - CONFIG.treeHeight / 2;
                const r = 250 * (1 - (y + 300)/600) * Math.random();
                
                mesh.userData = {
                    treePos: { x: r * Math.cos(theta), y: y, z: r * Math.sin(theta) },
                    scatterPos: { x: (Math.random()-0.5)*1200, y: (Math.random()-0.5)*1200, z: (Math.random()-0.5)*1200 }
                };
                mesh.position.copy(mesh.userData.treePos);
                geometryGroup.add(mesh);
                particles.push(mesh);
            }
            scene.add(geometryGroup);
            scene.add(photoGroup);
        }

        function createPhotoMesh(tex) {
            tex.colorSpace = THREE.SRGBColorSpace; 
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(30, 40), new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide }));
            const y = Math.random() * 600 - 300;
            const r = 250 * (1 - (y + 300)/600) + 30;
            const theta = Math.random() * Math.PI * 2;
            mesh.userData = {
                treePos: { x: r * Math.cos(theta), y: y, z: r * Math.sin(theta) },
                scatterPos: { x: (Math.random()-0.5)*1000, y: (Math.random()-0.5)*1000, z: (Math.random()-0.5)*1000 }
            };
            // åˆå§‹ä½ç½®è®¾ä¸ºå½“å‰æ¨¡å¼çš„ä½ç½®ï¼Œé˜²æ­¢åŠ è½½å»¶è¿Ÿå¯¼è‡´é”™ä½
            mesh.position.copy(mesh.userData[currentMode === 'TREE' ? 'treePos' : 'scatterPos']);
            mesh.lookAt(0,y,0);
            photoGroup.add(mesh);
            photos.push(mesh);
        }

        function transformTo(mode) {
            if(currentMode === mode) return;
            currentMode = mode;
            document.getElementById('gesture-status').innerText = mode === 'TREE' ? "TREE MODE" : "SCATTER MODE";
            if(activePhoto) {
                new TWEEN.Tween(activePhoto.scale).to({x:1,y:1,z:1}, 800).start();
                activePhoto = null;
            }
            const k = mode === 'TREE' ? 'treePos' : 'scatterPos';
            const ease = mode === 'TREE' ? TWEEN.Easing.Back.Out : TWEEN.Easing.Cubic.Out;
            particles.forEach(p => new TWEEN.Tween(p.position).to(p.userData[k], 2000).easing(ease).start());
            photos.forEach(p => new TWEEN.Tween(p.position).to(p.userData[k], 2000).easing(ease)
                .onUpdate(() => { if(mode==='SCATTER') p.lookAt(camera.position); else p.lookAt(0, p.position.y, 0); }).start());
        }

        function grabPhoto() {
            if(currentMode === 'ZOOM' || !photos.length) return;
            activePhoto = photos[Math.floor(Math.random() * photos.length)];
            currentMode = 'ZOOM';
            document.getElementById('gesture-status').innerText = "PHOTO ZOOM";
            const target = new THREE.Vector3().copy(camera.position).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(150));
            new TWEEN.Tween(activePhoto.position).to(target, 1000).easing(TWEEN.Easing.Elastic.Out).onUpdate(()=>activePhoto.lookAt(camera.position)).start();
            new TWEEN.Tween(activePhoto.scale).to({x:4,y:4,z:4}, 1000).start();
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            if(currentMode === 'TREE') {
                const t = Date.now() * 0.0005;
                camera.position.x = Math.sin(t) * 900;
                camera.position.z = Math.cos(t) * 900;
                camera.lookAt(0, 50, 0);
            } else if (currentMode === 'SCATTER' && !activePhoto) {
                camera.position.x += (targetRotY * 500 - camera.position.x) * 0.1;
                camera.position.y += (targetRotX * 300 - camera.position.y) * 0.1;
                camera.lookAt(0,0,0);
            }
            composer.render();
        }

        async function initMediaPipe() {
            const videoElement = document.getElementById('video-feed');
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cam = new window.Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: "user"
            });
            await cam.start();
        }

        function onResults(results) {
            const statusEl = document.getElementById('gesture-status');
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const handX = (lm[9].x - 0.5) * 2;
                const handY = (lm[9].y - 0.5) * 2;
                targetRotY = -handX * 2; targetRotX = handY * 2;
                const d = (i,j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);
                const fingersUp = [8,12,16,20].filter(i => lm[i].y < lm[i-2].y).length;
                const isPinch = d(4,8) < 0.05;
                if(isPinch) { statusEl.classList.add('active-gesture'); grabPhoto(); }
                else if (fingersUp >= 4) { statusEl.classList.add('active-gesture'); transformTo('SCATTER'); }
                else if (fingersUp === 0) { statusEl.classList.add('active-gesture'); transformTo('TREE'); }
                else { statusEl.classList.remove('active-gesture'); }
            }
        }
    </script>
</body>
</html>
