<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åŒ—åŒ—çš„åœ£è¯æ ‘</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: "Microsoft YaHei", sans-serif; -webkit-tap-highlight-color: transparent; }
        
        /* 1. å¯åŠ¨å±‚ */
        #start-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 999;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
        }
        #start-btn {
            padding: 15px 40px; border: 2px solid #FFD700; background: rgba(255, 215, 0, 0.1);
            color: #FFD700; font-size: 18px; border-radius: 30px; cursor: pointer;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.4); text-transform: uppercase; font-weight: bold;
        }

        /* 2. æ ‡é¢˜æ–‡å­— (æ¨¡æ‹Ÿå‘å…‰æ•ˆæœ) */
        #main-title {
            position: absolute; top: 12%; width: 100%; text-align: center;
            font-size: 40px; font-weight: bold; color: #fff;
            text-shadow: 
                0 0 10px #FFD700,
                0 0 20px #FFD700,
                0 0 40px #FF4500;
            z-index: 5; pointer-events: none; letter-spacing: 5px;
            animation: glow 3s infinite alternate;
        }
        @keyframes glow {
            from { text-shadow: 0 0 10px #FFD700, 0 0 20px #FFD700; opacity: 0.9; }
            to { text-shadow: 0 0 20px #FFD700, 0 0 40px #FFD700, 0 0 60px #FF4500; opacity: 1; }
        }

        /* 3. ç•Œé¢ UI */
        #ui-layer { pointer-events: none; position: absolute; width: 100%; height: 100%; z-index: 10; top:0; left:0;}
        .hud-bottom { 
            position: absolute; bottom: 20px; width: 100%; text-align: center; 
            color: rgba(255,255,255,0.4); font-size: 12px; 
        }
        
        #gesture-status {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            color: rgba(255,255,255,0.3); font-size: 18px; font-weight: bold;
            text-shadow: 0 2px 4px #000; transition: 0.2s;
        }
        .active-gesture { color: #FFD700 !important; text-shadow: 0 0 20px #FFD700; transform: scale(1.1); }

        #video-feed {
            position: absolute; top: 10px; right: 10px; width: 80px; height: 100px;
            transform: scaleX(-1); border: 1px solid #444; opacity: 0.3; object-fit: cover; z-index: 20; border-radius: 5px;
        }

        #error-log {
            position: fixed; bottom: 10px; left: 10px; color: red; font-size: 10px; z-index: 1000;
            background: rgba(0,0,0,0.8); max-width: 80%; pointer-events: none;
        }
        
        /* æ‰‹æœºé€‚é… */
        @media (max-width: 600px) {
            #main-title { font-size: 32px; top: 10%; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="start-overlay">
        <h1 style="color:#FFD700; margin-bottom: 20px; text-shadow: 0 0 10px #FF4500;">ğŸ„ åŒ—åŒ—çš„åœ£è¯æ ‘</h1>
        <button id="start-btn">ç‚¹å‡»å¼€å¯é­”æ³• / START</button>
        <div style="margin-top: 15px; font-size: 12px; color: #888;">éœ€å…è®¸æ‘„åƒå¤´æƒé™ä»¥è¯†åˆ«æ‰‹åŠ¿</div>
    </div>

    <div id="main-title">åŒ—åŒ—çš„åœ£è¯æ ‘</div>

    <div id="error-log"></div>

    <div id="ui-layer">
        <div id="gesture-status">ç­‰å¾…æ‰‹åŠ¿...</div>
        <div class="hud-bottom">ğŸ– å¼ å¼€æ•£å¼€ | âœŠ æ¡æ‹³åˆæ‹¢ | ğŸ‘Œ æåˆçœ‹ç…§ç‰‡</div>
    </div>

    <video id="video-feed" playsinline muted></video>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- é…ç½®åŒºï¼šåœ¨æ­¤å¤„ä¿®æ”¹ç…§ç‰‡æ–‡ä»¶å ---
        const MY_PHOTOS = [
            'photos/1.jpg',
            'photos/2.jpg',
            'photos/3.jpg',
            'photos/4.jpg',
            'photos/5.jpg',
            'photos/6.jpg'
            // ç¡®ä¿æ–‡ä»¶åå’ŒGitHubä¸Šå®Œå…¨ä¸€è‡´
        ];

        function log(msg) {
            console.log(msg);
            if(msg.includes("Error") || msg.includes("Fail")) {
                document.getElementById('error-log').innerText = msg;
            }
        }

        const CONFIG = {
            colors: { 
                gold: 0xFFD700, 
                red: 0xDC143C, // æ·±çº¢
                dark: 0x1a1a1a // è¿‘ä¹é»‘è‰²çš„æ·±ç°
            },
            particleCount: 1400, 
            treeHeight: 650,
            treeRadius: 280
        };

        let scene, camera, renderer, composer;
        let particles = [], photos = [];
        let geometryGroup = new THREE.Group();
        let photoGroup = new THREE.Group();
        let currentMode = 'TREE';
        let activePhoto = null;
        let targetRotX = 0, targetRotY = 0;

        // å¯åŠ¨é€»è¾‘
        document.getElementById('start-btn').addEventListener('click', async function() {
            this.innerText = "æ­£åœ¨åˆå§‹åŒ–...";
            try {
                await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' } });
                document.getElementById('start-overlay').style.display = 'none';
                initThree();
                initMediaPipe();
            } catch (e) {
                this.innerText = "æƒé™è¢«æ‹’ç»";
                log("Error: " + e.message);
                alert("è¯·å…è®¸æ‘„åƒå¤´æƒé™ï¼Œç„¶ååˆ·æ–°é¡µé¢ï¼");
            }
        });

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.0008);

            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 1, 2500);
            camera.position.set(0, 100, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            container.appendChild(renderer.domElement);

            // --- ç¯å…‰ ---
            const ambient = new THREE.AmbientLight(0xffffff, 1.2);
            scene.add(ambient);
            
            // é¡¶éƒ¨é‡‘è‰²ä¸»å…‰
            const topLight = new THREE.PointLight(CONFIG.colors.gold, 4.0, 1500);
            topLight.position.set(0, 600, 100);
            scene.add(topLight);

            // åº•éƒ¨çº¢è‰²æ°›å›´å…‰
            const bottomLight = new THREE.PointLight(CONFIG.colors.red, 2.5, 1000);
            bottomLight.position.set(0, -400, 200);
            scene.add(bottomLight);

            // --- è¾‰å…‰ç‰¹æ•ˆ (Bloom) ---
            const renderScene = new RenderPass(scene, camera);
            const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloom.threshold = 0.15; // é˜ˆå€¼
            bloom.strength = 1.8;   // å¼ºåº¦
            bloom.radius = 0.8;     // åŠå¾„
            
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloom);

            // åˆ›å»ºåœºæ™¯å…ƒç´ 
            addTopOrnament();
            createDecorations();
            loadMyPhotos();

            scene.add(geometryGroup);
            scene.add(photoGroup);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
            animate();
        }

        // 1. æ·»åŠ é¡¶éƒ¨é’»çŸ³
        function addTopOrnament() {
            const geo = new THREE.OctahedronGeometry(40, 0);
            const mat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.gold,
                emissive: CONFIG.colors.gold,
                emissiveIntensity: 2.0, // å¼ºè‡ªå‘å…‰
                metalness: 1.0,
                roughness: 0.0
            });
            const topStar = new THREE.Mesh(geo, mat);
            topStar.position.set(0, CONFIG.treeHeight / 2 + 40, 0);
            
            // è‡ªè½¬åŠ¨ç”»
            new TWEEN.Tween(topStar.rotation).to({y: Math.PI * 4}, 10000).repeat(Infinity).start();
            scene.add(topStar);
        }

        // 2. åˆ›å»ºåœ£è¯æ ‘ç²’å­ (é‡‘çƒã€çº¢çƒã€é»‘æ–¹å—)
        function createDecorations() {
            const sphereGeo = new THREE.SphereGeometry(1, 16, 16);
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);

            const matGold = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.gold, roughness: 0.1, metalness: 1.0, 
                emissive: CONFIG.colors.gold, emissiveIntensity: 0.5 
            });
            const matRed = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.red, roughness: 0.2, metalness: 0.8,
                emissive: CONFIG.colors.red, emissiveIntensity: 0.3
            });
            const matDark = new THREE.MeshStandardMaterial({ 
                color: CONFIG.colors.dark, roughness: 0.9, metalness: 0.2
            });

            for (let i = 0; i < CONFIG.particleCount; i++) {
                let mesh, scaleBase;
                let rnd = Math.random();

                if (rnd < 0.45) { // 45% é‡‘çƒ
                    mesh = new THREE.Mesh(sphereGeo, matGold);
                    scaleBase = 6 + Math.random() * 8;
                } else if (rnd < 0.75) { // 30% çº¢çƒ
                    mesh = new THREE.Mesh(sphereGeo, matRed);
                    scaleBase = 5 + Math.random() * 6;
                } else { // 25% æ·±è‰²æ–¹å—
                    mesh = new THREE.Mesh(boxGeo, matDark);
                    scaleBase = 4 + Math.random() * 5;
                    mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
                }
                mesh.scale.setScalar(scaleBase);

                // æ ‘å½¢åˆ†å¸ƒ
                const theta = Math.random() * Math.PI * 2;
                const y = Math.pow(Math.random(), 0.9) * CONFIG.treeHeight - CONFIG.treeHeight / 2; // é‡å¿ƒåä¸‹
                const r = CONFIG.treeRadius * (1 - (y + CONFIG.treeHeight/2)/CONFIG.treeHeight) * Math.sqrt(Math.random());
                
                mesh.userData = {
                    treePos: { x: r * Math.cos(theta), y: y, z: r * Math.sin(theta) },
                    scatterPos: { x: (Math.random()-0.5)*1500, y: (Math.random()-0.5)*1500, z: (Math.random()-0.5)*1500 }
                };
                mesh.position.copy(mesh.userData.treePos);
                
                geometryGroup.add(mesh);
                particles.push(mesh);
            }
        }

        // 3. åŠ è½½ç…§ç‰‡
        function loadMyPhotos() {
            const loader = new THREE.TextureLoader();
            MY_PHOTOS.forEach(path => {
                loader.load(path, (tex) => { createPhotoMesh(tex); }, undefined, 
                (err) => console.log(`Photo load failed: ${path}`));
            });
        }

        function createPhotoMesh(tex) {
            tex.colorSpace = THREE.SRGBColorSpace;
            // è¾¹æ¡†æè´¨ (ç™½è‰²) + å›¾ç‰‡æè´¨
            const geometry = new THREE.PlaneGeometry(32, 42); 
            const material = new THREE.MeshBasicMaterial({ map: tex, side: THREE.DoubleSide });
            
            const mesh = new THREE.Mesh(geometry, material);
            
            // éšæœºåˆ†å¸ƒåœ¨æ ‘è¡¨é¢é™„è¿‘
            const y = Math.random() * (CONFIG.treeHeight - 100) - (CONFIG.treeHeight/2 - 50);
            const r = CONFIG.treeRadius * (1 - (y + CONFIG.treeHeight/2)/CONFIG.treeHeight) + 20; // ç¨å¾®æµ®åœ¨è¡¨é¢
            const theta = Math.random() * Math.PI * 2;

            mesh.userData = {
                treePos: { x: r * Math.cos(theta), y: y, z: r * Math.sin(theta) },
                scatterPos: { x: (Math.random()-0.5)*1000, y: (Math.random()-0.5)*1000, z: (Math.random()-0.5)*1000 }
            };
            
            mesh.position.copy(mesh.userData.treePos);
            mesh.lookAt(0, y, 0); // é¢å‘ä¸­å¿ƒ
            
            photoGroup.add(mesh);
            photos.push(mesh);
        }

        // 4. çŠ¶æ€åˆ‡æ¢åŠ¨ç”»
        function transformTo(mode) {
            if(currentMode === mode) return;
            currentMode = mode;
            
            // é€€å‡ºæ”¾å¤§æ¨¡å¼
            if(activePhoto) {
                new TWEEN.Tween(activePhoto.scale).to({x:1, y:1, z:1}, 800).start();
                activePhoto = null;
            }

            const k = mode === 'TREE' ? 'treePos' : 'scatterPos';
            const ease = mode === 'TREE' ? TWEEN.Easing.Elastic.Out.config(1, 0.75) : TWEEN.Easing.Exponential.Out;

            // ç²’å­åŠ¨ç”»
            particles.forEach(p => {
                new TWEEN.Tween(p.position).to(p.userData[k], 2000 + Math.random()*500).easing(ease).start();
                if(mode === 'SCATTER' && p.geometry.type === 'BoxGeometry') {
                     new TWEEN.Tween(p.rotation).to({x:Math.random()*6, y:Math.random()*6}, 2500).start();
                }
            });

            // ç…§ç‰‡åŠ¨ç”»
            photos.forEach(p => {
                new TWEEN.Tween(p.position).to(p.userData[k], 2000).easing(ease)
                .onUpdate(() => { 
                    if(mode === 'SCATTER') p.lookAt(camera.position); 
                    else p.lookAt(0, p.position.y, 0); 
                }).start();
            });
        }

        // 5. æŠ“å–ç…§ç‰‡ (æ”¾å¤§)
        function grabPhoto() {
            if(currentMode === 'ZOOM' || photos.length === 0) return;
            
            // éšæœºé€‰ä¸€å¼ æˆ–è€…é€‰ç¦»å±å¹•ä¸­å¿ƒæœ€è¿‘çš„
            activePhoto = photos[Math.floor(Math.random() * photos.length)];
            currentMode = 'ZOOM';
            document.getElementById('gesture-status').innerText = "æŸ¥çœ‹ç…§ç‰‡";

            const target = new THREE.Vector3().copy(camera.position).add(camera.getWorldDirection(new THREE.Vector3()).multiplyScalar(150));
            
            new TWEEN.Tween(activePhoto.position).to(target, 1000).easing(TWEEN.Easing.Elastic.Out)
                .onUpdate(() => activePhoto.lookAt(camera.position)).start();
            new TWEEN.Tween(activePhoto.scale).to({x: 5, y: 5, z: 5}, 1000).start();
        }

        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();

            if(currentMode === 'TREE') {
                const t = Date.now() * 0.0005;
                camera.position.x = Math.sin(t * 0.5) * 1000;
                camera.position.z = Math.cos(t * 0.5) * 1000;
                camera.position.y = 100 + Math.sin(t) * 50;
                camera.lookAt(0, 100, 0);
            } else if (currentMode === 'SCATTER' && !activePhoto) {
                // æ‰‹åŠ¿æ—‹è½¬è§†è§’
                camera.position.x += (targetRotY * 600 - camera.position.x) * 0.1;
                camera.position.y += (targetRotX * 400 - camera.position.y) * 0.1;
                camera.lookAt(0,0,0);
            }
            composer.render();
        }

        // --- MediaPipe æ‰‹åŠ¿è¯†åˆ« ---
        async function initMediaPipe() {
            const videoElement = document.getElementById('video-feed');
            const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            hands.onResults(onResults);
            
            const cam = new window.Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 320, height: 240, facingMode: "user"
            });
            await cam.start();
        }

        function onResults(results) {
            const statusEl = document.getElementById('gesture-status');
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                
                // 1. æ˜ å°„æ‰‹æŒä½ç½®åˆ°æ—‹è½¬
                const handX = (lm[9].x - 0.5) * 2;
                const handY = (lm[9].y - 0.5) * 2;
                targetRotY = -handX * 2; targetRotX = handY * 2;

                // 2. ç®€å•çš„æ‰‹åŠ¿åˆ¤æ–­
                const fingersUp = [8,12,16,20].filter(i => lm[i].y < lm[i-2].y).length;
                const d = (i,j) => Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);
                const isPinch = d(4,8) < 0.05; // æ‹‡æŒ‡å’Œé£ŸæŒ‡æåˆ

                if (isPinch) {
                    statusEl.classList.add('active-gesture'); 
                    statusEl.innerText = "ğŸ‘Œ æåˆï¼šæŸ¥çœ‹";
                    grabPhoto();
                } else if (fingersUp >= 4) {
                    statusEl.classList.add('active-gesture'); 
                    statusEl.innerText = "ğŸ– å¼ å¼€ï¼šæ•£å¼€";
                    transformTo('SCATTER');
                } else if (fingersUp <= 1) {
                    statusEl.classList.add('active-gesture'); 
                    statusEl.innerText = "âœŠ æ¡æ‹³ï¼šåˆæ‹¢";
                    transformTo('TREE');
                } else {
                    statusEl.classList.remove('active-gesture');
                    statusEl.innerText = "ç­‰å¾…æŒ‡ä»¤...";
                }
            }
        }
    </script>
</body>
</html>
